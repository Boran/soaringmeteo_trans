package org.soaringmeteo.wrf

import io.circe.Json
import org.slf4j.LoggerFactory
import org.soaringmeteo.grib.Grib

object MakeWRFJson {

  private val logger = LoggerFactory.getLogger(getClass)

  def main(args: Array[String]): Unit = {
    val wrfLocFile      = os.Path(args(0))
    val gribsDir        = os.Path(args(1))
    val gribFilesSuffix = args(2)
    val targetDir       = os.Path(args(3))
    makeJson(wrfLocFile, gribsDir, gribFilesSuffix, targetDir)
  }

  /**
   * @param wrfLocFile      CSV file containing WRF points
   * @param gribsDir        Directory containing the output of the wrf.exe program
   * @param gribFilesSuffix Suffix of the files generated by wrf (e.g., “2017-09-08_Init2017-09-07_18Z+12h.nc”)
   * @param targetDir       Directory where to write the JSON files
   *
   * We currently generate one JSON file per domain (d02.json, d03.json, d04.json, and d05.json).
   * Each file contains a JSON object indexed by point id (2nd column in the CSV file), whose
   * value is a JSON array containing the forecast data for each hour of the day (between 08:00 CEST and
   * 17:00 CEST)
   */
  def makeJson(
    wrfLocFile: os.Path,
    gribsDir: os.Path,
    gribFilesSuffix: String,
    targetDir: os.Path
  ): Unit = {
    logger.info("Starting MakeWRFJson")

    logger.debug("Parsing WRF locations")
    val locations = {
      val csvContent =
        os.read.lines(wrfLocFile)
          .filter(line => line.trim.nonEmpty && !line.startsWith("#"))
          .mkString("\n")
      WrfLocation.parse(csvContent)
    }

    logger.debug("Processing wrf.exe output")
    os.remove.all(targetDir)
    os.makeDir.all(targetDir)

    locations
      .groupBy(_.domain)
      .foreach { case (domain, locations) =>
        Grib.bracket(gribsDir / s"wrfout_${domain}_$gribFilesSuffix") { grib =>
          logger.debug(s"Processing ${locations.size} points in domain $domain")
          val forecasts = WrfGrib.process(grib, locations)
          val forecastsJson = Json.obj(forecasts.map { case (id, locationForecasts) =>
            id -> Json.arr(locationForecasts.map(Forecast.encoder.apply): _*)
          }: _*)
          val targetFile = targetDir / s"$domain.json"
          os.write(targetFile, forecastsJson.noSpaces)
        }
      }

    logger.info("Stopping MakeWRFJson")
  }

}
